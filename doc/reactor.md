# Reactor模型

### 为什么需要Reactor模型
　　Reactor模型是同步IO复用下的事件驱动模型。在Epoll已经能够完成并发处理几十万条连接请求的前提下，Reactor模型的意义在于能够极大的简化网络应用的开发。epoll返回rdllist上的就绪事件struct epoll_event后，我们需要通过其中的data字段，获得对应对象的上下文，结合上下文状态查询此时应当选择哪个业务方法处理，调用相应方法完成操作后，若请求结束，则删除对象及其上下文。整个过程可能会非常繁琐，不利于开发与维护，也不符合面向对象的思想。Reactor模型是解决上述工程问题的一种途径，将事件驱动框架与具体业务分离，将不同类型请求之间用面向对象的思想分离。
  
### Reactor模型结构
  * 文件描述符（handle）：由操作系统提供的资源，用于识别每一个事件，如Socket描述符、一般文件描述符、信号的值等。如epollfd、socketfd；
  * 同步事件多路分离器（event demultiplexer）：**事件的到来是随机的、异步的，无法预知程序何时收到一个客户连接请求或收到一个信号。所以程序要循环等待并处理事件，这就是事件循环（event loop）**。在事件循环中，等待事件一般使用I/O复用技术实现。I/O框架库一般将各种I/O复用系统调用封装成统一的接口，称为事件多路分离器。调用者会被阻塞，直到分离器分离的描述符集上有事件发生。如Epoll；
  * 事件处理器（event handler）：I/O框架库提供的事件处理器通常是由一个或多个模板函数组成的接口。事件处理器中的回调函数（必须是非阻塞的）一般声明为虚函数，以支持用户拓展。如Channel；
  * 具体的事件处理器（concrete event handler）：用户继承事件处理器的模板函数实现自己的事件处理器，即**具体事件处理器是事件处理器接口的实现**。它实现了应用程序提供的某个服务。如Acceptor、Connector；
  * Reactor管理器（reactor）：定义了一些接口，用于应用程序控制事件调度，以及应用程序注册、删除事件处理器和相关的描述符。它是事件处理器的调度核心。 **Reactor管理器使用同步事件分离器来等待事件的发生。一旦事件发生，Reactor管理器先是分离每个事件，然后调度事件处理器，最后调用相关的模板函数来处理这个事件**，如EventLoop。
  
### Reactor模型与Proactor模型比较
  * Reactor模型是同步IO，Proactor模型是异步IO；
  * Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的。Reactor中通知应用程序自己读取或者写入数据到自己的缓冲区，而Proactor模式中，应用程序不需要进行实际的读写过程，它只需要从缓冲区读取或者写入即可，操作系统会读取缓冲区或者写入缓冲区到真正的IO设备，完成后再通知应用程序。
